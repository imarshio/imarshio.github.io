import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as i,c as h,d as e,e as a,f as t,b as r}from"./app-BxKY2YuM.js";const p={},o=r('<h2 id="通读全书-我得到了什么" tabindex="-1"><a class="header-anchor" href="#通读全书-我得到了什么"><span>通读全书，我得到了什么？</span></a></h2><p>回顾一下，我读这本书的初衷，与其说初衷，不如说是一个契机，在有意的安排下，我接触到了这本书，当时的我，已经大大小小接触过几个公司的业务系统了，本以为我对系统设计有了自己的理解，现在想来，也不过是技术栈丰富后的堆积产物罢了。</p><p>为何如此锐评自己？因为在读这本书前，如果我接到一个构建系统的任务，我应该不会考虑这个系统的成本，或者说会默认我想要的总是存在的；应该也不一定会想到未来如何接入监控系统。以及一些我现在都无法考虑到的点。</p><p>为什么会有这种感觉？可以说是经验不足所带来的心虚，也可以说是纸上谈兵终究是纸上谈兵，理论精英不等于实践不会出错。</p><p>本文中，周老师主讲的还是以分布式系统为主的分布式架构设计，有关分布式的起源，发展，以及随之而来的种种问题，扩展到为了解决这些问题而研究出的新技术，具体如如何保证分布式服务下的数据一致性。</p><h2 id="架构要考虑哪些方面" tabindex="-1"><a class="header-anchor" href="#架构要考虑哪些方面"><span>架构要考虑哪些方面？</span></a></h2><h3 id="业务角度" tabindex="-1"><a class="header-anchor" href="#业务角度"><span>业务角度</span></a></h3><p>我认为设计一个系统最重要的莫过于其初衷及未来规划，也就是其业务出发点，我感觉也可以理解为业务价值。</p><h3 id="技术角度" tabindex="-1"><a class="header-anchor" href="#技术角度"><span>技术角度</span></a></h3><p>所选技术栈，正如本书所讲的大部分内容，从基础设施到方法论，从方法论再到具像化的设计。</p><h3 id="资源角度" tabindex="-1"><a class="header-anchor" href="#资源角度"><span>资源角度</span></a></h3><p>人力资源，成本，时间，</p><h3 id="其他云云" tabindex="-1"><a class="header-anchor" href="#其他云云"><span>其他云云</span></a></h3><p>不要过度设计</p><h2 id="看待架构的不同角度" tabindex="-1"><a class="header-anchor" href="#看待架构的不同角度"><span>看待架构的不同角度</span></a></h2><h3 id="从技术角度看待架构" tabindex="-1"><a class="header-anchor" href="#从技术角度看待架构"><span>从技术角度看待架构</span></a></h3><p>一个完美的架构最终也不过是服务于一个系统（单体或分布式系统），终究是逃不出系统的边界，如何设计一个合理又完美的系统</p><p>不再扯远了，以上只是我在一个较长的时间线中，阅读到其他架构相关的文章随记，如下回归主题。</p><h2 id="章节-演进中的架构" tabindex="-1"><a class="header-anchor" href="#章节-演进中的架构"><span>章节：演进中的架构</span></a></h2><p><strong>提问：什么是架构？</strong></p>',20),c={href:"https://www.infoq.cn/article/an-informal-discussion-on-architecture-part01",target:"_blank",rel:"noopener noreferrer"},d=r('<p><strong>提问：什么是软件架构？</strong></p><p><strong>提问：什么是分布式？</strong></p><p>我们一提到架构就会想到分布式，感觉分布式架构才是一个词？这之间的详细关系是什么？分布式架构优劣是什么？</p><h2 id="章节-架构师的视角-访问远程服务" tabindex="-1"><a class="header-anchor" href="#章节-架构师的视角-访问远程服务"><span>章节：架构师的视角--访问远程服务</span></a></h2><h3 id="什么是rpc-什么是rest" tabindex="-1"><a class="header-anchor" href="#什么是rpc-什么是rest"><span>什么是RPC？什么是REST？</span></a></h3><h4 id="rpc" tabindex="-1"><a class="header-anchor" href="#rpc"><span>RPC</span></a></h4><p>Remote Procedure Call，远程服务调用。</p><p>顾名思义，RPC就是用来调用远程服务的，那么为什么需要调用远程服务呢？为什么不用本地服务呢？</p><p>本地服务调用，也可以叫进程间通信，本地进程共享内存</p><h4 id="rest" tabindex="-1"><a class="header-anchor" href="#rest"><span>REST</span></a></h4>',10),u={href:"https://restfulapi.net/",target:"_blank",rel:"noopener noreferrer"},g={href:"https://aws.amazon.com/cn/compare/the-difference-between-rpc-and-rest/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://zhuanlan.zhihu.com/p/636491028",target:"_blank",rel:"noopener noreferrer"},f=r('<h4 id="所以rest与rpc的区别是什么" tabindex="-1"><a class="header-anchor" href="#所以rest与rpc的区别是什么"><span>所以REST与RPC的区别是什么？</span></a></h4><p>两者都是，先将我个人理解的答案，以一个案例来说</p><p>在开发过程中，对后端接口进行请求时，我们会有POST、GET、UPDATE、DELETE四种最常见的请求方式，其余几种请求方式暂不讨论。</p><p>假如有一个需求需要查看某篇文章的信息</p><ul><li>按照RPC的原则，</li></ul><h2 id="章节-架构师的视角-事务处理" tabindex="-1"><a class="header-anchor" href="#章节-架构师的视角-事务处理"><span>章节：架构师的视角--事务处理</span></a></h2><p>在印象中，事务发生的场景只存在于数据库，消息队列，其他场景很少会遇到，基本没有遇到过。在目前遇到的事务处理过程中，通常来说，通过数据库配置+代码（锁）就可以解决99%的问题了，另外1%不知道是否存在，目前本人还没遇到过。</p><p>按照周老师的说法，如上情况还处在事务的<strong>内部一致性</strong>阶段。</p><blockquote><p>什么是内部一致性？</p><p>引用周老师的话来说：“当一个服务只使用一个数据源时，通过 A、I、D 来获得一致性是最经典的做法，也是相对容易的。此时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为“内部一致性”。”</p></blockquote><h3 id="caid-or-acid" tabindex="-1"><a class="header-anchor" href="#caid-or-acid"><span>CAID or ACID</span></a></h3><p>C（Consistency）：一致性 A（Atomic）：原子性 I（Isolation）：隔离性 D（Durablity）：持久性</p><p>C是目的，AID是手段。</p><h3 id="如何实现持久性-原子性" tabindex="-1"><a class="header-anchor" href="#如何实现持久性-原子性"><span>如何实现持久性 原子性？</span></a></h3><p><strong>持久性</strong>：即持久，简单理解，对数据库而言，写入磁盘的数据才有持久这一特性，而没有写入磁盘的数据则没有持久这一特性。</p><p>实现持久性的方法还是蛮多的，市面上常见的有</p><p><strong>原子性</strong>：原子不可拆分，原子性即一个操作（CRUD）是一个整体，不可拆分，要么整个操作都不执行，如果执行，那么一整个操作都要执行。</p><p><strong>提问：什么是CAP？</strong></p><ul><li>C（Consistency）：一致性</li><li>A（Available）：可用性</li><li>P（partition Tolerance）：分区容错，无法避免</li></ul><p>CAP定理指出，在一个分布式系统中，涉及数据共享问题时，如上三个特性最多只能同时满足其中三个。</p><h3 id="分布式事务" tabindex="-1"><a class="header-anchor" href="#分布式事务"><span>分布式事务</span></a></h3><h2 id="章节-架构师的视角-分流" tabindex="-1"><a class="header-anchor" href="#章节-架构师的视角-分流"><span>章节：架构师的视角--分流</span></a></h2><h2 id="章节-架构师的视角-安全性" tabindex="-1"><a class="header-anchor" href="#章节-架构师的视角-安全性"><span>章节：架构师的视角--安全性</span></a></h2><p>最简单的安全实现，就是&quot;闭关锁国&quot;。通过不将自己的服务暴露到外网，以及将一切外网拉入黑名单就是最简单的安全实现（对外不对内）。</p><h2 id="章节-分布式的基石-分布式共识算法" tabindex="-1"><a class="header-anchor" href="#章节-分布式的基石-分布式共识算法"><span>章节：分布式的基石--分布式共识算法</span></a></h2><p>TODO 算法的实现</p><h3 id="paxos" tabindex="-1"><a class="header-anchor" href="#paxos"><span>Paxos</span></a></h3><h3 id="multi-paxos" tabindex="-1"><a class="header-anchor" href="#multi-paxos"><span>Multi Paxos</span></a></h3><h3 id="gossip" tabindex="-1"><a class="header-anchor" href="#gossip"><span>Gossip</span></a></h3><h3 id="raft" tabindex="-1"><a class="header-anchor" href="#raft"><span>Raft</span></a></h3><h2 id="章节-分布式的基石-从类库到服务" tabindex="-1"><a class="header-anchor" href="#章节-分布式的基石-从类库到服务"><span>章节：分布式的基石--从类库到服务</span></a></h2><h2 id="章节-分布式的基石-流量治理" tabindex="-1"><a class="header-anchor" href="#章节-分布式的基石-流量治理"><span>章节：分布式的基石--流量治理</span></a></h2><h2 id="章节-分布式的基石-可靠通讯" tabindex="-1"><a class="header-anchor" href="#章节-分布式的基石-可靠通讯"><span>章节：分布式的基石--可靠通讯</span></a></h2><h2 id="章节-分布式的基石-可观测性" tabindex="-1"><a class="header-anchor" href="#章节-分布式的基石-可观测性"><span>章节：分布式的基石--可观测性</span></a></h2><p>本章节主要是讲可视化操作，包括日志的可视化，监控的可视化，任务执行的链路追踪，这些可视化操作对于一个完整的系统来说，是不可或缺的部分。</p><h2 id="章节-不可变的基础设施" tabindex="-1"><a class="header-anchor" href="#章节-不可变的基础设施"><span>章节：不可变的基础设施</span></a></h2>',35);function x(b,k){const n=s("ExternalLinkIcon");return i(),h("div",null,[o,e("p",null,[a("针对这个问题，在网上我找到一篇文章，比较符合我预期的答案，"),e("a",c,[a("架构漫谈（一）：什么是架构？"),t(n)]),a("。")]),d,e("p",null,[a("我们参考"),e("a",u,[a("官方文档"),t(n)]),a("给我们的解释， 参考：")]),e("ul",null,[e("li",null,[e("a",g,[a("https://aws.amazon.com/cn/compare/the-difference-between-rpc-and-rest/"),t(n)])]),e("li",null,[e("a",m,[a("https://zhuanlan.zhihu.com/p/636491028"),t(n)])])]),f])}const E=l(p,[["render",x],["__file","凤凰架构.html.vue"]]),C=JSON.parse('{"path":"/books/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84.html","title":"凤凰架构","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2023-11-03T00:00:00.000Z","category":["architect","架构"],"title":"凤凰架构","description":"通读全书，我得到了什么？ 回顾一下，我读这本书的初衷，与其说初衷，不如说是一个契机，在有意的安排下，我接触到了这本书，当时的我，已经大大小小接触过几个公司的业务系统了，本以为我对系统设计有了自己的理解，现在想来，也不过是技术栈丰富后的堆积产物罢了。 为何如此锐评自己？因为在读这本书前，如果我接到一个构建系统的任务，我应该不会考虑这个系统的成本，或者说会...","head":[["meta",{"property":"og:url","content":"https://imarshio.github.io/books/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"Blog"}],["meta",{"property":"og:title","content":"凤凰架构"}],["meta",{"property":"og:description","content":"通读全书，我得到了什么？ 回顾一下，我读这本书的初衷，与其说初衷，不如说是一个契机，在有意的安排下，我接触到了这本书，当时的我，已经大大小小接触过几个公司的业务系统了，本以为我对系统设计有了自己的理解，现在想来，也不过是技术栈丰富后的堆积产物罢了。 为何如此锐评自己？因为在读这本书前，如果我接到一个构建系统的任务，我应该不会考虑这个系统的成本，或者说会..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-03-26T11:12:40.000Z"}],["meta",{"property":"article:author","content":"Marshio"}],["meta",{"property":"article:published_time","content":"2023-11-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-26T11:12:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"凤凰架构\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-26T11:12:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Marshio\\",\\"url\\":\\"https://marshio.com\\"}]}"]]},"headers":[{"level":2,"title":"通读全书，我得到了什么？","slug":"通读全书-我得到了什么","link":"#通读全书-我得到了什么","children":[]},{"level":2,"title":"架构要考虑哪些方面？","slug":"架构要考虑哪些方面","link":"#架构要考虑哪些方面","children":[{"level":3,"title":"业务角度","slug":"业务角度","link":"#业务角度","children":[]},{"level":3,"title":"技术角度","slug":"技术角度","link":"#技术角度","children":[]},{"level":3,"title":"资源角度","slug":"资源角度","link":"#资源角度","children":[]},{"level":3,"title":"其他云云","slug":"其他云云","link":"#其他云云","children":[]}]},{"level":2,"title":"看待架构的不同角度","slug":"看待架构的不同角度","link":"#看待架构的不同角度","children":[{"level":3,"title":"从技术角度看待架构","slug":"从技术角度看待架构","link":"#从技术角度看待架构","children":[]}]},{"level":2,"title":"章节：演进中的架构","slug":"章节-演进中的架构","link":"#章节-演进中的架构","children":[]},{"level":2,"title":"章节：架构师的视角--访问远程服务","slug":"章节-架构师的视角-访问远程服务","link":"#章节-架构师的视角-访问远程服务","children":[{"level":3,"title":"什么是RPC？什么是REST？","slug":"什么是rpc-什么是rest","link":"#什么是rpc-什么是rest","children":[]}]},{"level":2,"title":"章节：架构师的视角--事务处理","slug":"章节-架构师的视角-事务处理","link":"#章节-架构师的视角-事务处理","children":[{"level":3,"title":"CAID or ACID","slug":"caid-or-acid","link":"#caid-or-acid","children":[]},{"level":3,"title":"如何实现持久性 原子性？","slug":"如何实现持久性-原子性","link":"#如何实现持久性-原子性","children":[]},{"level":3,"title":"分布式事务","slug":"分布式事务","link":"#分布式事务","children":[]}]},{"level":2,"title":"章节：架构师的视角--分流","slug":"章节-架构师的视角-分流","link":"#章节-架构师的视角-分流","children":[]},{"level":2,"title":"章节：架构师的视角--安全性","slug":"章节-架构师的视角-安全性","link":"#章节-架构师的视角-安全性","children":[]},{"level":2,"title":"章节：分布式的基石--分布式共识算法","slug":"章节-分布式的基石-分布式共识算法","link":"#章节-分布式的基石-分布式共识算法","children":[{"level":3,"title":"Paxos","slug":"paxos","link":"#paxos","children":[]},{"level":3,"title":"Multi Paxos","slug":"multi-paxos","link":"#multi-paxos","children":[]},{"level":3,"title":"Gossip","slug":"gossip","link":"#gossip","children":[]},{"level":3,"title":"Raft","slug":"raft","link":"#raft","children":[]}]},{"level":2,"title":"章节：分布式的基石--从类库到服务","slug":"章节-分布式的基石-从类库到服务","link":"#章节-分布式的基石-从类库到服务","children":[]},{"level":2,"title":"章节：分布式的基石--流量治理","slug":"章节-分布式的基石-流量治理","link":"#章节-分布式的基石-流量治理","children":[]},{"level":2,"title":"章节：分布式的基石--可靠通讯","slug":"章节-分布式的基石-可靠通讯","link":"#章节-分布式的基石-可靠通讯","children":[]},{"level":2,"title":"章节：分布式的基石--可观测性","slug":"章节-分布式的基石-可观测性","link":"#章节-分布式的基石-可观测性","children":[]},{"level":2,"title":"章节：不可变的基础设施","slug":"章节-不可变的基础设施","link":"#章节-不可变的基础设施","children":[]}],"git":{"createdTime":1711028956000,"updatedTime":1711451560000,"contributors":[{"name":"marshio","email":"marshioman@gmail.com","commits":3}]},"readingTime":{"minutes":5.55,"words":1665},"filePathRelative":"books/凤凰架构.md","localizedDate":"November 3, 2023","excerpt":"<h2>通读全书，我得到了什么？</h2>\\n<p>回顾一下，我读这本书的初衷，与其说初衷，不如说是一个契机，在有意的安排下，我接触到了这本书，当时的我，已经大大小小接触过几个公司的业务系统了，本以为我对系统设计有了自己的理解，现在想来，也不过是技术栈丰富后的堆积产物罢了。</p>\\n<p>为何如此锐评自己？因为在读这本书前，如果我接到一个构建系统的任务，我应该不会考虑这个系统的成本，或者说会默认我想要的总是存在的；应该也不一定会想到未来如何接入监控系统。以及一些我现在都无法考虑到的点。</p>\\n<p>为什么会有这种感觉？可以说是经验不足所带来的心虚，也可以说是纸上谈兵终究是纸上谈兵，理论精英不等于实践不会出错。</p>","autoDesc":true}');export{E as comp,C as data};
